# OS

## 死锁
### 死锁与饥饿
饥饿的原因：分配策略的问题，某些进程发生长时间的等待，
地额不代表发生了死锁，但会有进程被无限期推迟

死锁是资源竞争，几个进程互相等待对方手里的资源。发生死锁的进程一定是在阻塞态，
而发生饥饿的进程可能是阻塞态，也可能是就绪态(长时间得不到CPU)

### 死锁产生的条件 
1. 互斥条件，进程要对资源进行排他性使用
2. 不可剥夺，进程获得的资源在使用完成之前，不得被其他进程抢走
3. 请求并保持，进程已经站有一个资源，并对别的资源提出要求(并且此资源已经被其他进程占用)
4. 循环等待，存在循环等待链

### 死锁的策略
1. 死锁预防
  - 预防死锁只需要破坏四个条件之一即可
   - 1. 破坏互斥： 不安全
   - 2. 破坏请求并保持：常用于易于保护和恢复的资源，例如CPU寄存器
   - 3. 破坏请求并保持：可采用预先静态资源分配法，资源没有满足就不让运行——系统资源被浪费
   - 4. 破坏循坏等待条件：可采用顺序资源法，给资源编号，规定每个进程按照序号递增的顺序请求资源。这样已经有大编号的就不会去申请小编号的资源.
2. 死锁避免
   - 系统在分配资源之前，先计算此次资源分配的安全性。
     安全状态是指系统能够按照某种进程推进顺序为每个进程分配资源，也就是找到一个安全序列
   - 银行家算法
3. 死锁检测和解除
- 死锁检测：S为死锁的条件是S状态的资源分配图是不可完全简化的-死锁定理
- 死锁解除：资源剥夺法，撤销进程法，进程回退法（自愿释放资源）
