import{_ as a,c as i,a3 as e,o as t}from"./chunks/framework.C4Vvvhxx.js";const p=JSON.parse('{"title":"OS","description":"","frontmatter":{},"headers":[],"relativePath":"gjdw/1.md","filePath":"gjdw/1.md","lastUpdated":1738674411000}'),o={name:"gjdw/1.md"};function r(s,l,d,n,h,c){return t(),i("div",null,l[0]||(l[0]=[e('<h1 id="os" tabindex="-1">OS <a class="header-anchor" href="#os" aria-label="Permalink to &quot;OS&quot;">​</a></h1><h2 id="死锁" tabindex="-1">死锁 <a class="header-anchor" href="#死锁" aria-label="Permalink to &quot;死锁&quot;">​</a></h2><h3 id="死锁与饥饿" tabindex="-1">死锁与饥饿 <a class="header-anchor" href="#死锁与饥饿" aria-label="Permalink to &quot;死锁与饥饿&quot;">​</a></h3><p>饥饿的原因：分配策略的问题，某些进程发生长时间的等待， 地额不代表发生了死锁，但会有进程被无限期推迟</p><p>死锁是资源竞争，几个进程互相等待对方手里的资源。发生死锁的进程一定是在阻塞态， 而发生饥饿的进程可能是阻塞态，也可能是就绪态(长时间得不到CPU)</p><h3 id="死锁产生的条件" tabindex="-1">死锁产生的条件 <a class="header-anchor" href="#死锁产生的条件" aria-label="Permalink to &quot;死锁产生的条件&quot;">​</a></h3><ol><li>互斥条件，进程要对资源进行排他性使用</li><li>不可剥夺，进程获得的资源在使用完成之前，不得被其他进程抢走</li><li>请求并保持，进程已经站有一个资源，并对别的资源提出要求(并且此资源已经被其他进程占用)</li><li>循环等待，存在循环等待链</li></ol><h3 id="死锁的策略" tabindex="-1">死锁的策略 <a class="header-anchor" href="#死锁的策略" aria-label="Permalink to &quot;死锁的策略&quot;">​</a></h3><ol><li>死锁预防</li></ol><ul><li>预防死锁只需要破坏四个条件之一即可</li><li><ol><li>破坏互斥： 不安全</li></ol></li><li><ol start="2"><li>破坏请求并保持：常用于易于保护和恢复的资源，例如CPU寄存器</li></ol></li><li><ol start="3"><li>破坏请求并保持：可采用预先静态资源分配法，资源没有满足就不让运行——系统资源被浪费</li></ol></li><li><ol start="4"><li>破坏循坏等待条件：可采用顺序资源法，给资源编号，规定每个进程按照序号递增的顺序请求资源。这样已经有大编号的就不会去申请小编号的资源.</li></ol></li></ul><ol start="2"><li>死锁避免 <ul><li>系统在分配资源之前，先计算此次资源分配的安全性。 安全状态是指系统能够按照某种进程推进顺序为每个进程分配资源，也就是找到一个安全序列</li><li>银行家算法</li></ul></li><li>死锁检测和解除</li></ol><ul><li>死锁检测：S为死锁的条件是S状态的资源分配图是不可完全简化的-死锁定理</li><li>死锁解除：资源剥夺法，撤销进程法，进程回退法（自愿释放资源）</li></ul>',12)]))}const m=a(o,[["render",r]]);export{p as __pageData,m as default};
