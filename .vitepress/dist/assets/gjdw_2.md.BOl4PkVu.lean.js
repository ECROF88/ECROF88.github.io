import{_ as l,c as e,a3 as t,o as i}from"./chunks/framework.C4Vvvhxx.js";const u=JSON.parse('{"title":"内存管理","description":"","frontmatter":{},"headers":[],"relativePath":"gjdw/2.md","filePath":"gjdw/2.md","lastUpdated":1739105684000}'),o={name:"gjdw/2.md"};function r(s,a,d,n,c,p){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h1><h3 id="逻辑地址和物理地址" tabindex="-1">逻辑地址和物理地址 <a class="header-anchor" href="#逻辑地址和物理地址" aria-label="Permalink to &quot;逻辑地址和物理地址&quot;">​</a></h3><p>逻辑地址也是相对地址，对于32为系统，逻辑地址空间的范围是0~2^32-1</p><p>操作系统通过MMU（内存管理部件）将进程使用的逻辑地址转换成物理地址</p><h3 id="程序的链接与装入" tabindex="-1">程序的链接与装入 <a class="header-anchor" href="#程序的链接与装入" aria-label="Permalink to &quot;程序的链接与装入&quot;">​</a></h3><ol><li>绝对装入 只适用于单道程序环境。</li><li>可重定位装入，也称静态重定位。装入模块的起始地址通常是从0开始，程序使用的都是相对于始址逻辑地址。 装入内存后时必须分配要求的全部空间，一旦装入内存就不能移动了。</li><li>动态运行时装入，也称动态重定位。若程序要在内存中移动，需要春运动态的装入方式。 装入内存后并不会立即将装入的模块中的相对地址转换为绝对地址，而是将地址转换推迟到程序执行时才进行</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>优点：可以将程序分配到不连续的存储区，运行期间动态的申请分配内存；便于程序段的共享</p></div><h4 id="三种链接方式" tabindex="-1">三种链接方式 <a class="header-anchor" href="#三种链接方式" aria-label="Permalink to &quot;三种链接方式&quot;">​</a></h4><ol><li>静态链接 程序运行之前，将个目标模块和所需的库函数链接成一个完整的装入模块，以后不拆开 需要解决的问题：</li></ol><ul><li>修改相对地址，所有目标模块都是从0开始的相对地址</li><li>变换外部调用符号</li></ul><ol start="2"><li>装入时动态链接 ：装入内存时边装入边链接</li><li>运行时动态链接 ：执行时需要某个模块的时候才会进行链接，未用到的不会调入内存，加快程序装入过程，节约内存空间</li></ol><p>可重入程序主要是通过共享使用同一块存储空间的，或者通过静态链接的方式将所需的程序段映射到相关进程中去 优点就是减少了对程序段的调入调出，减少了对换的数量</p><p>多级页表，将页表控制在一页之内，减少页表所占的连续内存空间</p>',13)]))}const m=l(o,[["render",r]]);export{u as __pageData,m as default};
